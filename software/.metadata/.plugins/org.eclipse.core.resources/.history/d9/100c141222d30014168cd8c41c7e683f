#include <stdio.h>
#include <string.h>
#include "includes.h"
#include "altera_up_avalon_character_lcd.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <math.h>
#include "altera_avalon_jtag_uart_regs.h"
#include <io.h>
#include "altera_avalon_fifo_util.h"
#include "altera_avalon_fifo_regs.h"
#include "altera_avalon_fifo.h"
#include "altera_up_avalon_audio.h"
#include "altera_up_avalon_audio_and_video_config.h"
#include "MidiDriver.h"


#define     BUFFER_SIZE    128
#define   TASK_STACKSIZE       2048
#define INPUT_POLLING_TASK_PRIORITY      1
#define AUDIO_TASK_PRIORITY				 2
#define NUMBER_OF_LASER 8
OS_STK    inputPollingTaskStack[TASK_STACKSIZE];
OS_STK    audioTaskStack[TASK_STACKSIZE];

OS_EVENT * laserStatusChanged;

void audioTask(void* pdata)
{
	INT8U err;
    alt_up_audio_dev * audio_dev;
    alt_up_av_config_dev * audio_config_dev;

    unsigned int buffer[BUFFER_SIZE];
    int i = 0;

    audio_config_dev = alt_up_av_config_open_dev("/dev/audio_and_video_config_0");
    if ( audio_config_dev == NULL)
        printf("Error: could not open audio config device \n");
    else
        printf("Opened audio config device \n");

    /* Open Devices */
    audio_dev = alt_up_audio_open_dev ("/dev/audio_0");
    if ( audio_dev == NULL)
        printf("Error: could not open audio device \n");
    else
        printf("Opened audio device \n");

    /* Configure WM8731 */
    alt_up_av_config_reset(audio_config_dev);
    alt_up_audio_reset_audio_core(audio_dev);

    /* Write to configuration registers in the audio codec; see datasheet for what these values mean */
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x0, 0x17);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x1, 0x17);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x2, 0x50);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x3, 0x50);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x4, 0x15);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x5, 0x06);
    alt_up_av_config_write_audio_cfg_register(audio_config_dev, 0x6, 0x00);

	altera_avalon_fifo_init(FIFO_0_OUT_CSR_BASE, 0x0, 10, FIFO_0_OUT_CSR_FIFO_DEPTH-10);

	unsigned int data;
	unsigned int level;
	altera_avalon_fifo_read_fifo(FIFO_0_OUT_BASE, FIFO_0_OUT_CSR_BASE);
	while (1){
		level = altera_avalon_fifo_read_level(FIFO_0_OUT_CSR_BASE);
		if (level>0){
			for (i=0;i<level;i++){
				buffer[i]=altera_avalon_fifo_read_fifo(FIFO_0_OUT_BASE, FIFO_0_OUT_CSR_BASE)>>16 + 0x7fff;
			}
		}


        alt_up_audio_write_fifo (audio_dev, buffer, level, ALT_UP_AUDIO_RIGHT);
        alt_up_audio_write_fifo (audio_dev, buffer, level, ALT_UP_AUDIO_LEFT);



	}
}

void inputPollingTask(void* pdata){
	alt_up_character_lcd_dev * char_lcd_dev;
	int laserStatus;
	int* laserStatusPointer =(int* )SWITCH_BASE;
	int previousLaserStatus;
	INT8U err;

	//=========== init LCD ===========
	char_lcd_dev = alt_up_character_lcd_open_dev ("/dev/character_lcd_0");
	if ( char_lcd_dev == NULL)
		alt_printf ("Error: could not open character LCD device\n");
	else
		alt_printf ("Opened character LCD device\n");
	alt_up_character_lcd_init (char_lcd_dev);
	alt_up_character_lcd_set_cursor_pos(char_lcd_dev, 0, 0);
	alt_up_character_lcd_string(char_lcd_dev, "MIDIGeneratorPrototype");

	//=========== Start polling  ===========
	while (1){
		OSSemPend(laserStatusChanged, 0, &err);
		previousLaserStatus = laserStatus;
		laserStatus = *laserStatusPointer;
		laserStatus = pow(2,NUMBER_OF_LASER)-1 - laserStatus; //reverse all bits
		if (previousLaserStatus!=laserStatus){
			printf("%x\n",laserStatus);

			printLaserStatusOnLCD(char_lcd_dev,laserStatus);	//For debugging
			handleLaserStatusChange(previousLaserStatus,laserStatus);
		}
		OSTimeDlyHMSM(0, 0, 0, 50);
	}
}

/*
 * Handles changes on laserStatus, and send the corresponding MIDI signal to midiOut
 * Input: int previousStatus, int currentStatus
 */
void handleLaserStatusChange(int previousStatus, int currentStatus){
	int i;
	int laserToPitchMappingTable[]={60,62,64,65,67,69,71,72};
	unsigned noteType; //0 = off 1 = on
	//Find bits that were changed
	int differentBits = previousStatus^currentStatus;		//XOR: 100 ^ 110 = 010
	int* midiOutPointer = (int*) MIDIOUT_0_BASE;
	for (i=0;i<NUMBER_OF_LASER;i++){
		if( ((1 << i) & (differentBits)) == (1 << i) ){		//if laser i is changed
			noteType = ((currentStatus &  (1 << i)) ==  (1 << i)) ?  1: 0;
			*midiOutPointer =  getMidiData(i,noteType);
			if (noteType==1){
				turnOnVoice(laserToPitchMappingTable[i]);
			}else{
				turnOffVoice(laserToPitchMappingTable[i]);
			}

		}
	}
}

/*
 * This function construct midi signal according to the midi specification 1.0
 * More information about the specification: http://www.somascape.org/midi/tech/spec.html
 * Input: int laserIndex, int noteType (0 = off 1 = on)
 * Output: int midiData
 */
int getMidiData(int laserIndex, int noteType){

	int laserToPitchMappingTable[]={60,62,64,65,67,69,71,72};	//C4 D4 E4 F4 G4 A4 B4 C5
	int statusByte;
	int pitchByte;
	int velocityBtye;
	int midiData;

	statusByte = 144; //10010000 Note On through midi channel 1
	pitchByte = laserToPitchMappingTable[laserIndex];
	if (noteType==1){
		//Defaults to 64 in the absence of velocity sensors
		velocityBtye = 64;
	}else{
		//when velocity is zero = Note Off
		velocityBtye = 0;
	}

	//formate: 	0 statusBtye 1	0 pitchByte 1	0 velocityByte 1
	midiData = (statusByte<<21) + (1<<20) + (0<<19) + (pitchByte<<11) + (1<<10) + (0<<9) + (velocityBtye<<1) +(1<<0);

	//printf("midiData %i\n",midiData);
	return midiData;
}

/*
 * Print laserStatus as 1 and 0 on the LCD for debugging.
 * Input: alt_up_character_lcd_dev * char_lcd_dev, int laserStatus
 */
void printLaserStatusOnLCD(alt_up_character_lcd_dev * char_lcd_dev, int laserStatus){
    static char message[9];
    message[0] = '\0';
    int i;
    for (i = 128; i > 0; i >>= 1){
        strcat(message, ((laserStatus & i) == i) ? "1" : "0");
    }
	alt_up_character_lcd_init (char_lcd_dev);
	alt_up_character_lcd_set_cursor_pos(char_lcd_dev, 0, 0);
	alt_up_character_lcd_string(char_lcd_dev,"Laser Status:");
	alt_up_character_lcd_set_cursor_pos(char_lcd_dev, 0, 1);
	alt_up_character_lcd_string(char_lcd_dev, message);
}

static void key_ISR( void * context) {
	OSSemPost(laserStatusChanged);

	//interrupt safe instructions...
	//Acknowledge the IRQ : Clear the edgecapture register by writing a 1 to it
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCH_BASE, 0xff);
}
int main(void){

	OSTaskCreateExt(inputPollingTask,
			NULL,
			(void *)&inputPollingTaskStack[TASK_STACKSIZE-1],
			INPUT_POLLING_TASK_PRIORITY,
			INPUT_POLLING_TASK_PRIORITY,
			inputPollingTaskStack,
			TASK_STACKSIZE,
			NULL,
			0);

	OSTaskCreateExt(audioTask,
			NULL,
			(void *)&audioTaskStack[TASK_STACKSIZE-1],
			AUDIO_TASK_PRIORITY,
			AUDIO_TASK_PRIORITY,
			audioTaskStack,
			TASK_STACKSIZE,
			NULL,
			0);
	laserStatusChanged = OSSemCreate(0);
	alt_ic_isr_register(SWITCH_IRQ_INTERRUPT_CONTROLLER_ID, //alt_u32 ic_id
						SWITCH_IRQ, //alt_u32 irq
						key_ISR, //alt_isr_func isr
						NULL,
						NULL);
	//Setting interruptmask register to 1 enables key interrupts
	IOWR_ALTERA_AVALON_PIO_IRQ_MASK(SWITCH_BASE,0xff);
	OSStart();
	return 0;
}
